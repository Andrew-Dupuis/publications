<!DOCTYPE html>
<!-- saved from url=(0056)https://index.mirasmart.com/ISMRM2019/PDFfiles/4532.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>

</title>
     
    <script type="text/javascript" src="./4532_files/jquery.js.download"></script>
    

    <script src="./4532_files/MathJax.js.download" id=""></script>
    <link type="text/css" rel="stylesheet" href="./4532_files/css"><link type="text/css" rel="Stylesheet" href="./4532_files/bootstrap.min.css"><link type="text/css" rel="Stylesheet" href="./4532_files/bootstrap-theme.min.css"><link type="text/css" rel="Stylesheet" href="./4532_files/viewSubmissions.css"><meta name="viewport" content="width=device-width, initial-scale=1">  


    <script type="text/x-mathjax-config;executed=true">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$$$','$$$'], ["\\(","\\)"] ],
          processEscapes: true
        }
      });
    </script>

    
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body style=""><div id="MathJax_Message" style="display: none;"></div>
    
        <div id="SubmissionViewBreadCrumbWrapper"> </div>         
        <div id="contentWrapper" class="MainContentWrapper">   
           
    

	
    





<div class="col-lg-8 col-md-12 col-xm-12"> 
    <h3>
        <span id="ctl00_MainContent_ctl00_lblSubmissionID">4532</span>
    </h3>
    <span id="ctl00_MainContent_ctl00_submissionTitle" class="submissionTitle">MRF Dictionary Calculation and Visualization using GPU Compute Shaders</span>
    <div id="ctl00_MainContent_ctl00_autherBlock">        
        <div id="ctl00_MainContent_ctl00_AuthorsAndAffiliationsBlock_divBlockContainer" class="AffiliationBlockContainer">
    <div id="affAuthers" class="affAuthers">Andrew Dupuis<sup>1,2</sup>, Dan Ma<sup>3</sup>, and Mark A Griswold<sup>1,2,3</sup></div><i><div id="affOther" class="affOther"><br><sup>1</sup>Biomedical Engineering, Case Western Reserve University, Cleveland, OH, United States, <sup>2</sup>Interactive Commons, Case Western Reserve University, Cleveland, OH, United States, <sup>3</sup>Department of Radiology, School of Medicine, Case Western Reserve University, Cleveland, OH, United States</div></i>
</div>


    </div>

    <div id="ctl00_MainContent_ctl00_sectionsWrapper" class="sectionsWrapper">
	        
    <div class="divSectionBlock"><h3>Synopsis</h3><p class="synopsis">Dictionary
generation for Magnetic Resonance Fingerprinting (MRF) can be a computationally
intensive procedure, especially as complexity and density increase.
Conveniently, the majority of operations required for calculating dictionary
entries are already enumerated in conventional computer graphics shader
packages. Here, we leverage the decades of research and hardware development
spent to improve computer graphics optimization to remove the need for CUDA
parallelization and instead directly render MRF dictionaries into compressible
video files in virtually real time.</p></div><div class="divSectionBlock"><h3>Purpose</h3>The
need for rapid generation of dictionaries for Magnetic Resonance Fingerprinting
(MRF) [1] is significant. With the rise in interest in “realtime” MRF and the
corresponding increased need for patient-specific dictionaries, for example in
cardiac gated exams, opportunities to rapidly generate dictionaries while at
the scanner have gained interest. Much existing research has been put into
optimization of the dictionary generation process in Matlab or other research
software packages. However, these packages have significant overhead, and many
optimization approaches require CUDA-capable hardware. Here we instead chose to
focus on a universal GPU-accelerated dictionary generation technique using
standard computer graphics (CG) shaders to perform the simulation processing,
theoretically allowing any computer with even basic rendering capabilities to
benefit from the acceleration techniques.</div><div class="divSectionBlock"><h3>Methods</h3><p>Development of the system was performed in the Unity Engine to allow for rapid shader iteration and debugging, but the shaders developed are platform agnostic and can be used in either DirectX or OpenGL-based implementations. </p><p> A compute shader is used to perform the dictionary simulation. Compute shaders are implementations of the standard CG language functions in a runtime format that allows for additional datatype and dispatching flexibility. The dictionary to be rendered is defined in terms of minimum and maximum T1 and T2 values, as well as resolution percentages to be used for each “step” in the dictionary. Rather than using a constant step size/resolution across the whole dictionary, the resolution at any point is based on a geometric progression, with a constant percentage change between entries in the dictionary. Therefore, a percentile resolution increases result in exponential growth of total dictionary entries. Together, these variables define the resolution of the rendered output. Additional inputs include text files defining the flip angle, phase and TR for the dictionary.  </p><p>The T1 and T2 space is divided amongst an array of compute groups to parallelize the computation. An RGB texture is initialized that matches the resolution of the dictionary in T1/T2 space, and initial magnetizations are set. Standard Bloch simulation then proceeds for one timestep, with the magnetization at the end of the RF pulse and at TE is rendered to textures. Additionally, the real and imaginary components of the magnetization are rendered to the red and green components of the master dictionary texture. At each timestep, the previous timestep’s magnetizations are used as inputs, and an additional frame is added to the dictionary rendering.  </p><p>This process proceeds for as many frames/timesteps as desired, with the final output being a video file containing the dictionary simulation’s values. </p></div><div class="divSectionBlock"><h3>Results</h3>Dictionary
generation speed was tested with an isochromat simulation over 1000
TRs on a T1 range from 20:4000ms and a T2 range from 2:400ms on a Windows 10 PC
with a Xeon E5-2697 CPU, 64Gb of RAM, and an Nvidia 1080Ti GPU. The percent step
size of T1 and T2 was varied. Complete
timing comparisons at various dictionary sizes are visible in Figure 2.  Average simulation time reduction was 96.4%
across all tested dictionary resolutions.</div><div class="divSectionBlock"><h3>Discussion</h3><p>The
speed benefits of the preliminary work presented are not insignificant, indicating
that further shader optimization may yield even greater performance gains.
Input-output latency is the primary limitation of the system in its current
state, with GPU-&gt; CPU transfer speeds limiting the ability of the shader
system to freerun as quickly as it should. However, this limitation is
primarily in implementation rather than theory. </p><p>Future work would allow for
calculation of the dictionary as either an isochromat or as a group of spins
with variable spin numbers and time steps. Modifications should also be made to the work
assignment system to ignore impossible combinations of T1 and T2 values such as
where T2 is longer than T1.  
</p><p>With a render-based approach, dictionaries are not calculated into arrays but are instead rendered into
RGB video files. While this is a limitation when used with current reconstruction systems, requiring conversion into a more traditional format that reduces the overall
performance gain, the new storage approach introduces opportunities in dictionary
evaluation and compression.  First,
dictionaries can be “watched” along the TR dimension, with clear visualization
of magnetization at different T1 and T2 combinations. This allows an MRF
sequence designer to see the effects of their sequence, and to understand the
effects of their sequence on the T1-T2 domain. Second, the introduction of
video files as a storage medium opens paths to integration of existing
compression and streaming research, allowing for storage or in-situ streaming
of high resolution dictionaries without the need for massive uncompressed fully
sampled dictionaries.  </p></div><div class="divSectionBlock"><h3>Acknowledgements</h3>Siemens Healthcare, R01EB018108, NSF
1563805, R01DK098503, and R01HL094557. </div><div class="divSectionBlock"><h3>References</h3><p>[1] Ma, D. Gulani, V., Seiberlich, N., Liu, K., Sunshine, J., Duerk, J. and Griswold, M.A. (2013). Magnetic Resonance Fingerprinting. Nature. 2013 Mar 14. 495(7440): 187-192. </p><p> </p></div>
</div>
        
</div>
            
<div class="col-lg-3">
        <div id="ctl00_MainContent_ctl00_figures">
        <h3>Figures</h3>
        <div id="ctl00_MainContent_ctl00_figuresWrapper" class="figuresWrapper">
	
        
        <div class="divSectionBlock"><a id="ctl00_MainContent_ctl00_lnkImage_1" class="thumbnail" data-lightbox="figureImages" title="&lt;strong&gt;Figure 1:&lt;/strong&gt; &lt;em&gt;(click for animation)&amp;nbsp;&lt;/em&gt;A rendered dictionary depicting the magnitude of the real (red, values too low to be visible) and imaginary (green) components of a calculated dictionary. The TR domain is played back in time via the GIF.&amp;nbsp;T1 entries span from 20 to 4000ms from bottom to top incremented by 5% of the prior value. T2 entries similarly span from 2 to 400ms by 5% from left to right. Note the pattern of null values in the region where T2 exceeds T1, as would be expected.&amp;nbsp;" href="https://index.mirasmart.com/ISMRM2019/PDFfiles/images/7419/ISMRM2019-007419_Fig1.gif" target="_blank"><img src="./4532_files/ISMRM2019-007419_Fig1.gif" border="0" style="text-align:center;"></a><div class="thumbnailCaptions"><strong>Figure 1:</strong> <em>(click for animation) </em>A rendered dictionary depicting the magnitude of the real (red, values too low to be visible) and imaginary (green) components of a calculated dictionary. The TR domain is played back in time via the GIF. T1 entries span from 20 to 4000ms from bottom to top incremented by 5% of the prior value. T2 entries similarly span from 2 to 400ms by 5% from left to right. Note the pattern of null values in the region where T2 exceeds T1, as would be expected. </div><br><a id="ctl00_MainContent_ctl00_lnkImage_2" class="thumbnail" data-lightbox="figureImages" title="&lt;strong&gt;Figure 2&lt;/strong&gt;: Performance data for isochromat simulation over 1000 TRs on a T1 range
from 20:4000ms and a T2 range from 2:400ms. The percent step size of T1 and T2
was varied." href="https://index.mirasmart.com/ISMRM2019/PDFfiles/images/7419/ISMRM2019-007419_Fig2.PNG" target="_blank"><img src="./4532_files/ISMRM2019-007419_Fig2.PNG" border="0" style="text-align:center;"></a><div class="thumbnailCaptions"><strong>Figure 2</strong>: Performance data for isochromat simulation over 1000 TRs on a T1 range
from 20:4000ms and a T2 range from 2:400ms. The percent step size of T1 and T2
was varied.</div><br></div>
</div>
    </div>
</div>
<div id="ctl00_MainContent_ctl00_divFooter" style="font-weight:bold">
    <div class="col-lg-5 col-md-5 col-sm-5">
        Proc. Intl. Soc. Mag. Reson. Med. 27 (2019)
    </div>
    <span id="ctl00_MainContent_ctl00_lblProgramNumber" class="col-7 col-md-7 col-sm-7">4532</span>
</div>


        </div>
    


</body></html>